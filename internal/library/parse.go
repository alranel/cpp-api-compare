package library

import (
	"encoding/xml"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path"
	"runtime"
	"strconv"
	"strings"

	"github.com/alranel/cpp-api-compare/internal/config"
)

type doxygenIndexType struct {
	XMLName                   xml.Name `xml:"doxygenindex"`
	Text                      string   `xml:",chardata"`
	Xsi                       string   `xml:"xsi,attr"`
	NoNamespaceSchemaLocation string   `xml:"noNamespaceSchemaLocation,attr"`
	Version                   string   `xml:"version,attr"`
	Lang                      string   `xml:"lang,attr"`
	Compound                  []struct {
		Text   string `xml:",chardata"`
		Refid  string `xml:"refid,attr"`
		Kind   string `xml:"kind,attr"`
		Name   string `xml:"name"`
		Member []struct {
			Text  string `xml:",chardata"`
			Refid string `xml:"refid,attr"`
			Kind  string `xml:"kind,attr"`
			Name  string `xml:"name"`
		} `xml:"member"`
	} `xml:"compound"`
}

type memberdefType struct {
	Text     string `xml:",chardata"`
	Kind     string `xml:"kind,attr"`
	ID       string `xml:"id,attr"`
	Prot     string `xml:"prot,attr"`
	Static   string `xml:"static,attr"`
	Mutable  string `xml:"mutable,attr"`
	Const    string `xml:"const,attr"`
	Explicit string `xml:"explicit,attr"`
	Inline   string `xml:"inline,attr"`
	Virt     string `xml:"virt,attr"`
	Type     struct {
		Text string `xml:",chardata"`
		Ref  struct {
			Text    string `xml:",chardata"`
			Refid   string `xml:"refid,attr"`
			Kindref string `xml:"kindref,attr"`
		} `xml:"ref"`
	} `xml:"type"`
	Definition    string `xml:"definition"`
	Argsstring    string `xml:"argsstring"`
	Name          string `xml:"name"`
	Qualifiedname string `xml:"qualifiedname"`
	Initializer   struct {
		Text string `xml:",chardata"`
		Ref  struct {
			Text    string `xml:",chardata"`
			Refid   string `xml:"refid,attr"`
			Kindref string `xml:"kindref,attr"`
		} `xml:"ref"`
	} `xml:"initializer"`
	Briefdescription    string `xml:"briefdescription"`
	Detaileddescription struct {
		Text string `xml:",chardata"`
		Para struct {
			Text          string `xml:",chardata"`
			Parameterlist struct {
				Text          string `xml:",chardata"`
				Kind          string `xml:"kind,attr"`
				Parameteritem []struct {
					Text              string `xml:",chardata"`
					Parameternamelist struct {
						Text          string `xml:",chardata"`
						Parametername string `xml:"parametername"`
					} `xml:"parameternamelist"`
					Parameterdescription struct {
						Text string `xml:",chardata"`
						Para string `xml:"para"`
					} `xml:"parameterdescription"`
				} `xml:"parameteritem"`
			} `xml:"parameterlist"`
			Simplesect struct {
				Text string `xml:",chardata"`
				Kind string `xml:"kind,attr"`
				Para string `xml:"para"`
			} `xml:"simplesect"`
		} `xml:"para"`
	} `xml:"detaileddescription"`
	Inbodydescription string `xml:"inbodydescription"`
	Location          struct {
		Text      string `xml:",chardata"`
		File      string `xml:"file,attr"`
		Line      string `xml:"line,attr"`
		Column    string `xml:"column,attr"`
		Bodyfile  string `xml:"bodyfile,attr"`
		Bodystart string `xml:"bodystart,attr"`
		Bodyend   string `xml:"bodyend,attr"`
	} `xml:"location"`
	Param []struct {
		Text string `xml:",chardata"`
		Type struct {
			Text string `xml:",chardata"`
			Ref  struct {
				Text    string `xml:",chardata"`
				Refid   string `xml:"refid,attr"`
				Kindref string `xml:"kindref,attr"`
			} `xml:"ref"`
		} `xml:"type"`
		Declname string `xml:"declname"`
		Defval   struct {
			Text string `xml:",chardata"`
			Ref  struct {
				Text    string `xml:",chardata"`
				Refid   string `xml:"refid,attr"`
				Kindref string `xml:"kindref,attr"`
			} `xml:"ref"`
		} `xml:"defval"`
		Defname string `xml:"defname"`
	} `xml:"param"`
}

// Struct generated by https://xml-to-go.github.io/ in Ukraine
type doxygenFileType struct {
	XMLName                   xml.Name `xml:"doxygen"`
	Text                      string   `xml:",chardata"`
	Xsi                       string   `xml:"xsi,attr"`
	NoNamespaceSchemaLocation string   `xml:"noNamespaceSchemaLocation,attr"`
	Version                   string   `xml:"version,attr"`
	Lang                      string   `xml:"lang,attr"`
	Compounddef               struct {
		Text            string `xml:",chardata"`
		ID              string `xml:"id,attr"`
		Kind            string `xml:"kind,attr"`
		Language        string `xml:"language,attr"`
		Prot            string `xml:"prot,attr"`
		Compoundname    string `xml:"compoundname"`
		Basecompoundref []struct {
			Text  string `xml:",chardata"`
			Refid string `xml:"refid,attr"`
			Prot  string `xml:"prot,attr"`
			Virt  string `xml:"virt,attr"`
		} `xml:"basecompoundref"`
		Derivedcompoundref struct {
			Text  string `xml:",chardata"`
			Refid string `xml:"refid,attr"`
			Prot  string `xml:"prot,attr"`
			Virt  string `xml:"virt,attr"`
		} `xml:"derivedcompoundref"`
		Includes struct {
			Text  string `xml:",chardata"`
			Refid string `xml:"refid,attr"`
			Local string `xml:"local,attr"`
		} `xml:"includes"`
		Sectiondef []struct {
			Text      string          `xml:",chardata"`
			Kind      string          `xml:"kind,attr"`
			Memberdef []memberdefType `xml:"memberdef"`
		} `xml:"sectiondef"`
		Briefdescription    string `xml:"briefdescription"`
		Detaileddescription string `xml:"detaileddescription"`
		Inheritancegraph    struct {
			Text string `xml:",chardata"`
			Node []struct {
				Text  string `xml:",chardata"`
				ID    string `xml:"id,attr"`
				Label string `xml:"label"`
				Link  struct {
					Text  string `xml:",chardata"`
					Refid string `xml:"refid,attr"`
				} `xml:"link"`
				Childnode struct {
					Text     string `xml:",chardata"`
					Refid    string `xml:"refid,attr"`
					Relation string `xml:"relation,attr"`
				} `xml:"childnode"`
			} `xml:"node"`
		} `xml:"inheritancegraph"`
		Location struct {
			Text      string `xml:",chardata"`
			File      string `xml:"file,attr"`
			Line      string `xml:"line,attr"`
			Column    string `xml:"column,attr"`
			Bodyfile  string `xml:"bodyfile,attr"`
			Bodystart string `xml:"bodystart,attr"`
			Bodyend   string `xml:"bodyend,attr"`
		} `xml:"location"`
		Listofallmembers struct {
			Text   string `xml:",chardata"`
			Member []struct {
				Text  string `xml:",chardata"`
				Refid string `xml:"refid,attr"`
				Prot  string `xml:"prot,attr"`
				Virt  string `xml:"virt,attr"`
				Scope string `xml:"scope"`
				Name  string `xml:"name"`
			} `xml:"member"`
		} `xml:"listofallmembers"`
	} `xml:"compounddef"`
}

type parser struct {
	config       config.LibraryConfig
	doxygenIndex doxygenIndexType
	doxygenFiles map[string]doxygenFileType
}

func ReadLibrary(config config.LibraryConfig, keepBuildDir bool) *Library {
	// Initialize the return value
	lib := Library{
		LibraryName: config.Name,
		Classes:     make(map[string]Class),
		Defines:     make(map[string]string),
	}
	var globalFuncs []Method

	fmt.Printf("  * running Doxygen\n")
	// Create a temporary directory to store the doxygen output
	tmpDir, err := os.MkdirTemp("/tmp", "doxygen-build")
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	if keepBuildDir {
		fmt.Printf("  * temporary directory: %s\n", tmpDir)
	} else {
		defer os.RemoveAll(tmpDir)
	}

	// Generate the doxygen configuration file
	writeDoxyfile(path.Join(tmpDir, "Doxyfile"), config.Defines)

	// Copy the library files to the temporary directory
	for i, libraryPath := range config.Include {
		subdir := path.Join(tmpDir, strconv.Itoa(i))
		if runtime.GOOS == "darwin" {
			cmd := exec.Command("cp", "-R", libraryPath, subdir)
			cmd.Run()
		} else {
			cmd := exec.Command("cp", "-r", libraryPath, subdir)
			cmd.Run()
		}

		// Remove excluded subdirectories
		for _, exclude := range config.Exclude {
			if strings.HasPrefix(exclude, libraryPath) {
				excludedSubdir := strings.TrimPrefix(exclude, libraryPath)
				os.RemoveAll(path.Join(subdir, excludedSubdir))
			}
		}
	}

	// Generate the doxygen XML output
	{
		curDir, _ := os.Getwd()
		os.Chdir(tmpDir)
		cmd := exec.Command("doxygen")
		cmd.Run()
		os.Chdir(curDir)
	}

	// Initialize the parser object
	p := parser{
		config:       config,
		doxygenFiles: make(map[string]doxygenFileType),
	}

	// Read the doxygen XML output
	fmt.Printf("  * parsing output\n")
	{
		files, _ := os.ReadDir(path.Join(tmpDir, "xml"))
		for _, file := range files {
			if file.IsDir() {
				continue
			}
			if !strings.HasSuffix(file.Name(), ".xml") {
				continue
			}
			xmlFile, err := os.Open(path.Join(tmpDir, "xml", file.Name()))
			if err != nil {
				fmt.Println(err)
				return nil
			}
			defer xmlFile.Close()
			byteValue, _ := io.ReadAll(xmlFile)
			if file.Name() == "index.xml" {
				xml.Unmarshal(byteValue, &p.doxygenIndex)
			} else if file.Name() != "Doxyfile.xml" {
				var doxygenFile doxygenFileType
				err := xml.Unmarshal(byteValue, &doxygenFile)
				if err != nil {
					fmt.Printf("error while parsing %s: %v", file.Name(), err)
				}

				p.doxygenFiles[strings.TrimSuffix(file.Name(), ".xml")] = doxygenFile
			}
		}
	}

	// Read classes
	for _, compound := range p.doxygenIndex.Compound {
		if compound.Kind != "class" {
			continue
		}

		class := p.readClass(compound.Refid)
		lib.Classes[class.ClassName] = class
	}

	// Apply manually configured defines
	for _, define := range config.Defines {
		tokens := strings.Split(define, "=")
		if len(tokens) > 1 {
			lib.Defines[tokens[0]] = tokens[1]
		}
	}

	// Read singletons, global functions and defines
	for _, compound := range p.doxygenIndex.Compound {
		if !(compound.Kind == "file") && strings.HasSuffix(compound.Name, ".h") && compound.Kind != "namespace" {
			continue
		}

		for _, member := range compound.Member {
			if member.Kind == "variable" {
				class := p.readSingleton(compound.Refid, member.Refid)
				lib.Classes[class.ClassName] = class
			} else if member.Kind == "function" {
				f := p.readGlobalFunction(compound.Refid, member.Refid)
				if !f.DoesNotExist {
					globalFuncs = append(globalFuncs, f)
				}
			} else if member.Kind == "define" {
				val, f := p.readDefine(compound.Refid, member.Refid)
				lib.Defines[member.Name] = val
				if !f.DoesNotExist {
					globalFuncs = append(globalFuncs, f)
				}
			}
		}
	}

	// Alias classes, singletons and global functions according to defines
	for key, val := range lib.Defines {
		if val == "" {
			continue
		}
		if class, ok := lib.Classes[val]; ok {
			class2 := class
			class2.ClassName = key
			lib.Classes[key] = class2
		}

		for _, method := range globalFuncs {
			if method.MethodName == val || strings.HasPrefix(val, method.MethodName+"(") {
				method2 := method
				method2.MethodName = key
				globalFuncs = append(globalFuncs, method2)
			}
		}
	}

	// Alias classes and singletons belonging to the requested namespaces
	for className, class := range lib.Classes {
		classWithoutNamespace := p.removeNamespace(className)
		if classWithoutNamespace != className {
			class2 := class
			class2.ClassName = classWithoutNamespace
			lib.Classes[class2.ClassName] = class2
		}
	}

	// Alias global functions belonging to the requested namespaces
	for i, method := range globalFuncs {
		methodWithoutNamespace := p.removeNamespace(method.MethodName)
		if methodWithoutNamespace != method.MethodName {
			method2 := method
			method2.MethodName = methodWithoutNamespace
			globalFuncs[i] = method2
		}
	}

	lib.Classes["_"] = Class{
		ClassName: "_",
		Methods:   globalFuncs,
	}

	return &lib
}

func (p *parser) removeNamespace(name string) string {
	for _, namespace := range p.config.Namespaces {
		name = strings.TrimPrefix(name, namespace+"::")
	}
	return name
}

func (p *parser) readClass(refId string) Class {
	if refId == "" {
		return Class{}
	}
	doxygenFile := p.findDoxygenFile(refId)

	class := Class{
		ClassName: doxygenFile.Compounddef.Compoundname,
	}

	// Find the section containing public methods
	for _, sectiondef := range doxygenFile.Compounddef.Sectiondef {
		if sectiondef.Kind != "public-func" && sectiondef.Kind != "public-static-func" {
			continue
		}

		// Cycle through public methods
		for _, memberdef := range sectiondef.Memberdef {
			method := p.readMethod(memberdef)

			if memberdef.Name == class.ClassName {
				method.Ctor = true
			} else {
				// Detect constructors of namespaced classes, by getting the last token of the
				// qualified method name (like "Namespace::Class::Method") and comparing it to the
				// class name
				token := strings.Split(memberdef.Qualifiedname, "::")
				if token[len(token)-1] == token[len(token)-2] {
					method.Ctor = true
				}
			}

			// Skip destructors
			if strings.HasPrefix(memberdef.Name, "~") {
				continue
			}

			class.Methods = append(class.Methods, method)
		}
	}

	// Resolve inheritance, loop through base classes
	for _, basecompoundref := range doxygenFile.Compounddef.Basecompoundref {
		if basecompoundref.Prot != "public" {
			continue
		}

		// Parse the base class
		basecompoundrefID := basecompoundref.Refid
		if basecompoundref.Refid == "" {
			// If Doxygen was unable to link to the base class, try to find it manually
			for _, compound := range p.doxygenIndex.Compound {
				if compound.Kind != "class" {
					continue
				}
				if compound.Name == basecompoundref.Text {
					basecompoundrefID = compound.Refid
				} else {
					for _, namespace := range p.config.Namespaces {
						if compound.Name == namespace+"::"+basecompoundref.Text {
							basecompoundrefID = compound.Refid
							break
						}
					}
				}
			}
		}
		if basecompoundrefID == "" {
			fmt.Printf("    Warning: did not find base class %s of %s\n", basecompoundref.Text, class.ClassName)
		}
		baseClass := p.readClass(basecompoundref.Refid)

		// Loop through base class methods
		var parentMethods []Method
		for _, method := range baseClass.Methods {
			// Skip constructors of base classes
			if method.Ctor {
				continue
			}

			// Check if this base class method is overridden by child class
			isOverridden := false
			for _, childMethod := range class.Methods {
				if childMethod.Overrides(method) {
					isOverridden = true
				}
			}
			if !isOverridden {
				parentMethods = append(parentMethods, method)
			}
		}
		class.Methods = append(class.Methods, parentMethods...)
	}

	return class
}

func (p *parser) readMethod(memberdef memberdefType) Method {
	method := Method{
		MethodName: memberdef.Name,
		ReturnType: memberdef.Type.Text + memberdef.Type.Ref.Text,
	}
	method.ReturnType = strings.ReplaceAll(method.ReturnType, "boolean", "bool")
	for i, paramdef := range memberdef.Param {
		// Skip void parameters to enforce equivalence with methods having empty parameter list
		if i == 0 && paramdef.Type.Text == "void" {
			break
		}
		parameter := Parameter{
			ParameterName: paramdef.Declname,
			Type:          paramdef.Type.Text + paramdef.Type.Ref.Text,
			DefaultValue:  paramdef.Defval.Text,
		}
		parameter.Type = strings.ReplaceAll(parameter.Type, "boolean", "bool")
		parameter.Type = strings.TrimSpace(parameter.Type)
		method.Parameters = append(method.Parameters, parameter)
	}

	return method
}

func (p *parser) readSingleton(compoundRefId string, memberRefId string) Class {
	doxygenFile := p.findDoxygenFile(compoundRefId)

	// Find the section containing variables
	for _, sectiondef := range doxygenFile.Compounddef.Sectiondef {
		if sectiondef.Kind != "var" {
			continue
		}

		for _, memberdef := range sectiondef.Memberdef {
			if memberdef.ID != memberRefId || memberdef.Kind != "variable" || memberdef.Prot != "public" {
				continue
			}

			if memberdef.Type.Ref.Refid == "" {
				// Doxygen was not able to link this variable to a class,
				// but since we're interested in it, we'll try to guess it manually
				for _, compound := range p.doxygenIndex.Compound {
					if compound.Kind != "class" {
						continue
					}
					tokens := strings.Split(compound.Name, "::")
					if tokens[len(tokens)-1] == memberdef.Type.Text {
						memberdef.Type.Ref.Refid = compound.Refid
						break
					}
				}
			}

			class := p.readClass(memberdef.Type.Ref.Refid)
			class.ClassName = memberdef.Name
			class.IsSingleton = true
			return class
		}
	}
	return Class{}
}

func (p *parser) readDefine(compoundRefId string, memberRefId string) (string, Method) {
	doxygenFile := p.findDoxygenFile(compoundRefId)

	// Find the section containing defines
	for _, sectiondef := range doxygenFile.Compounddef.Sectiondef {
		if sectiondef.Kind != "define" {
			continue
		}

		for _, memberdef := range sectiondef.Memberdef {
			if memberdef.ID != memberRefId || memberdef.Kind != "define" || memberdef.Prot != "public" {
				continue
			}

			method := Method{DoesNotExist: true}
			if len(memberdef.Param) > 0 {
				// This define is actually a function-like macro
				method = Method{MethodName: memberdef.Name}
				for _, paramdef := range memberdef.Param {
					method.Parameters = append(method.Parameters, Parameter{
						ParameterName: paramdef.Defname,
					})
				}
			}

			return memberdef.Initializer.Ref.Text + memberdef.Initializer.Text, method
		}
	}
	return "", Method{DoesNotExist: true}
}

func (p *parser) readGlobalFunction(compoundRefId string, memberRefId string) Method {
	doxygenFile := p.findDoxygenFile(compoundRefId)

	// Find the section containing variables
	for _, sectiondef := range doxygenFile.Compounddef.Sectiondef {
		if sectiondef.Kind != "func" {
			continue
		}

		for _, memberdef := range sectiondef.Memberdef {
			if memberdef.ID != memberRefId || memberdef.Kind != "function" || memberdef.Prot != "public" {
				continue
			}

			return p.readMethod(memberdef)
		}
	}
	return Method{DoesNotExist: true}
}

func (p *parser) findDoxygenFile(refId string) doxygenFileType {
	for _, doxygenFile := range p.doxygenFiles {
		if doxygenFile.Compounddef.ID == refId {
			return doxygenFile
		}
	}
	return doxygenFileType{}
}
